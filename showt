#! /usr/bin/env python3
# vim: set ft=python ts=4 sw=4 et ai:

import os
import re
import sys
#  import mutagen
from os import path
from os.path import isdir
from glob import glob
import mutagen
from mutagen.mp3 import MP3
from mutagen.easyid3 import EasyID3
from mutagen.id3 import ID3NoHeaderError
from mutagen import File
import bpdb
# bpdb.set_trace()

'''
from libshowt.helpers import print_extra_items
from libshowt.helpers import eachkey
'''

# class AlbumHeader(__builtins__.dict):
class AlbumHeader(__builtins__.dict):
    def __init__(self, keys=['artist',
                             'album',
                             'date',
                             'venue',
                             'composer',
                             'genre',
                             'comment',
                             'setnumber',
                             'discnumber']):
        __builtins__.dict.__init__(self)
        for k in keys:
            self.update({k: None})
        self.keyorder = keys
        self.default_keyorder = ['artist',
                                 'album',
                                 'date',
                                 'venue',
                                 'composer',
                                 'genre',
                                 'comment',
                                 'setnumber',
                                 'discnumber']
        self.color = '\033[0;36m'
        
    def init(self, fname):
        mf = mf_open(fname)
        [self.update({k: mf.get(k)}) for k in self.keys() if k in mf]
        del mf

    def __sorted__(self):
        return [k for k in self.keyorder if self.get(k)]

    def show(self, color='', sort=True):
        output = ''
        if color:
            output = '%s' % self.color
        if sort:
            self.keyorder = self.default_keyorder
        for k in self.__sorted__():
            for n, v in enumerate(self.get(k)):
                if n == 0:
                    output += '%-12s: %-40s\n' % (k, v)
                elif v:
                    output += '%-12s  %-40s\n' % ('', v)
        if len(output) > len(self.color):
            print(output[:-1])
            if color:
                print("%s" % '\033[0m', end='')
            else:
                print('')


class OParser(object):
    def __init__(self, arglist=None):
        self.audio_types = ('.flac', '.ape', '.ogg', '.mp3')
        self.glob(arglist)
        optstr = ''.join([arg[1:] for arg in arglist if arg[0] == '-'])
        optstr = optstr.replace('l', 'b').replace('y', 'd')
        self.optstr = optstr
        self.mapping = {'a': 'artist',
                        'b': 'album',
                        'c': 'composer',
                        'd': 'date',
                        'v': 'venue',
                        'g': 'genre',
                        's': 'setnumber',
                        'C': 'comment',
                        'D': 'discnumber',
                        'n': 'tracknumber',
                        't': 'title'}
        self.hkeys = 'abcdvgsCD'
        self.ckeys = 'cdvDsntC'
        self.hdr = self.hkeys
        self.cols = self.ckeys
        self.keywords = [self.mapping[o] for o in self.ckeys]
        self.hdrwords = [self.mapping[o] for o in self.hkeys]
        self.prev = 0     

        try:
            self.comma = optstr.index(',')
        except ValueError:
            self.comma = None

        if not self.files:
            print('list some files, directories, or globs\n')

        if not (self.hdrkeys() or self.colkeys()):
            _help()
            exit()

    def hdrkeys(self):
        '''
        specify what info shows in the header
        '''
        if 'h' in self.optstr and self.comma:
            return [o for o in self.optstr if o in self.hkeys and
                    self.optstr.index(o) < self.comma] or self.hkeys
        if 'h' in self.optstr:
            return self.hkeys
        else:
            if self.comma:
                return([o for o in self.optstr if o in self.hkeys and
                    self.optstr.index(o) < self.comma] or '')
        return()

    def colkeys(self):
        '''
        if comma return everything right of the comma or everything
        '''
        if self.comma is None:
            return([o for o in self.optstr if
                    (o in self.ckeys or o in self.hkeys)] or '')
        return([o for o in self.optstr if o in self.ckeys and
                self.optstr.index(o) > self.comma] or self.ckeys)

    def hdrkeywords(self):
        return [self.mapping[o] for o in self.hdrkeys()]

    def colkeywords(self):
        return [self.mapping[o] for o in self.colkeys()]

    def fname_cols(self):
        mo = re.search('f[0-9]+', self.optstr)
        if mo:
            return int(mo.group()[1:])
        else:
            return 20 

    def sort(self, li=[]):
        if filter(lambda o: len(o) > 1, li):
            return [word for word in self.keywords if word in li]
        else:
            return [o for o in self.ckeys if o in li]

    def getext(self, fn):
        return path.splitext(fn)[1]

    def glob(self, arglist=[]):
        files = []
        filelist = []
        arglist = [arg for arg in arglist if arg[0] != '-']
        for arg in arglist:
            arg = re.sub('\[[\]]', '?', arg)
            if isdir(arg):
                arg = path.join(arg, '*')
            filelist.extend(glob(arg))
        filelist.sort()
        for ext in self.audio_types:
            files.extend([f for f in filelist if self.getext(f) == ext])
        self.files = files


class Shower:
    def __init__(self, parser=None):
        self.files = parser.files
        self.hdrkeys = parser.hdrkeys()
        self.colkeys = parser.colkeys()
        self.parser = parser
        if not (parser.hdrkeys() or parser.colkeys()):
            _help()
    def header(self):
        hdr = AlbumHeader(self.parser.hdrkeywords())
        hdr.init(self.files[0])

#        map(hdr.sync, self.files)
        return hdr

    def clean(self, files, opts=None):
        '''detects and optionally removes private tags from
        mp3s (option -x to clean)'''
        mp3files = [f for f in files if self.parser.getext(f) == '.mp3']
        for fn in mp3files:
            dirty = None
            cleaned = None
            try:
                d = MP3(fn)
            except BaseException:
                print(sys.exc_info())
                print("%f\t\tcan't open as MP3" % fn)
                continue
            for k in d:
                if k.startswith('PRIV:'):
                    if 'x' in opts:
                        d.pop(k)
                        cleaned = True
                    else:
                        dirty = True
            if cleaned:
                d.save()
                print('cleaned!')
            if dirty:
                print("%s has non-viewable PRIV frames, '-x' to clean" % fn)

    def has_cover(self, fname, func):
        # func is the appropriate class for mp3 or other filetype
        res = ''
        mfile = func(fname)
        if mfile.mime[0].endswith('/mp3'):
            res = 'artwork' if 'APIC:' in mfile.keys() else ''
        else:
            try:
                res = 'artwork' if mfile.pictures[0].data else ''
            except (AttributeError, IndexError):
                res = ''
        return res

    def show(self):
        '''show tag and tech info, format specified by options'''
        opts = self.parser.optstr
        header = self.header()
        self.color = 'p' in opts
        sort = 'u' not in opts
        
        header.show(self.color, sort)
        
        files = self.files
        fn = self.files[0]
        fnwidth = len(self.filename_column(fn, self.parser.fname_cols()))
        hdr = ''
        ext = self.parser.getext(fn)
        self.p = Printer(self.color)
        self.pr = self.p.pr
        if 'i' in opts:
            if '.mp3' == ext:
                self.pr('info', 35)
                self.pr('filename', fnwidth-6)
            else:
                self.pr('info', 29)
                self.pr('filename', fnwidth-6)
        else:
            self.pr('filename', (fnwidth-6))
        
        mf = mf_open(fn)
        hdr = ''
        self.grouping_dict = {}
        self.group_list = self.parser.hdrkeywords()
        for key in self.group_list:
            if key in mf:
                val = mf.get(key)[0]
                self.grouping_dict.update({key: val})
        # print the column headers
        s = self.do_header(mf, self.parser.colkeywords())
        self.p.prline(s)         
        
        hdr = ''
        for fn in self.files:
            mf = mf_open(fn)
            '''
            Grouping - if an item in the header changes, print
            that item header before the first song in that group
                self.color is a bool
            '''
            if 'G' in opts:
                self.grouping(fn, mf, self.color)
            # color is a bool
            func = MP3 if ext == '.mp3' else File
            try:
                info = func(fn).info
            except (IsADirectoryError, mutagen.MutagenError):
                return ''
            inf = ''
            if 'i' in opts:
                ext = ext.lower()
                self.pr(self.tech(ext, info), 1)
                self.pr(self.getlength(ext, info), 1)
                
                inf = self.tech(ext, info)
                inf += self.getlength(ext, info)
                
                cover = self.has_cover(fn, func)
                self.pr(self.has_cover(fn, func), 1)
                inf += cover
            
            '''
            print one column header or value for each key
            '''
            line = eachkey(self, self.parser, fn, mf, self.color, opts, files)
            self.p.prline(line)

            array = self.p.array
            for lis in array:
                width = 0
                for column in lis:
                    width = len(column) if len(column) > width else width
        if 'E' in opts:
            print_extra_items(fn, ext)

    def getlength(self, ext, info):
        sec = info.length % 60
        min = (info.length - sec) / 60
        s = '%02d:%02d' % (min, sec)
        return s

    def tech(self, ext, info):
        if ext == '.mp3':
            s = '%dch %s %3skbps %.1fkhz ' % (
                info.channels,
                info.protected,
                round(info.bitrate/1000),
                float(info.sample_rate/1000))
        else:
            s = '%dch %3skbps %.1fkhz ' % (
                info.channels,
                round(info.bitrate/1000),
                float(info.sample_rate/1000))
        return s
    
    def filename_column(self, fpath, width=20):
        fname = path.basename(fpath)
        fname, ext = path.splitext(fname)
        fname = fname[:width]
        fname += (width + 2 - len(fname))*' ' + ext
        return fname
       
    def grouping(self, fn, mf, color):
        local_hdr = []
        local_grouping_dict = {}
        [local_grouping_dict.update({k: mf.get(k, [''])[0]})
                for k in self.grouping_dict]
        if self.grouping_dict != local_grouping_dict:
            for key in local_grouping_dict:
                if local_grouping_dict[key] != self.grouping_dict[key]:
                    local_hdr.append(key)
                    
            self.grouping_dict = local_grouping_dict
            h = AlbumHeader(local_hdr)
            h.init(fn)
            h.show(color)

    def do_header(self, mf, colkeywords):
        '''
        print the column headers
        '''
        # print the column headers
        for k in colkeywords:
            # for each key
            hdr = ''
            if k in mf or True:
                v = ' ' + mf.get(k, [''])[0]
                if k == 'tracknumber':
                    hdr = ' t#'
                elif k == 'discnumber':
                    hdr = ' d#'
                elif k == 'setnumber':
                    hdr = ' s#'
                else:
                    hdr = k
                klen = len(hdr)
                vlen = len(v[:24])
                if k in ['tracknumber']:
                    nspaces = 1 
                elif k in ['comment', 'venue', 'composer', 'title']:
                    nspaces = 25 - klen
                else:
                    nspaces = klen-vlen if klen > vlen else vlen-klen
                self.pr(hdr, nspaces)
    
class Printer:
    '''
    tabbed printing with optional colors
    '''
    def __init__(self, mybool):
        self.clrstr = '\033[1;37m'
        self.pos = 0
        self.clr = 37
        self.line = ''
        self.mybool = mybool
        self.colnum = 0
        self.array = []
        self.linenum = 0

    def pr(self, data, numspaces):
        self.line += self.clrstr if self.mybool else ''
        self.line += data + ' ' * numspaces
        self.clrswap()
#        if self.linenum == 0:
#            if data:
#                self.array.append([data])
#        else:
#            if data:
#                self.array[self.colnum].append(data)
        self.colnum += 1
        self.pos += len(data) + numspaces

    def get_pos(self):
        return self.pos

    def get_line(self):
        return self.line

    def prline(self, s=''):
        print(s or self.line, end='\n')
        self.clr = 37
        self.clrstr = '\033[1;37m'
        self.line = ''
        self.colnum = 0
        self.linenum += 1
        # print(self.array)
#        self.array += [self.colnum]

    def clrswap(self):
        intensity = 1
        if self.clr == 37:
            self.clr = 32
        else:
            self.clr = 37
        self.clrstr = '\033[%d;%2sm' % (intensity, self.clr)

    def newline(self):
        self.line += '\n'
        self.line += self.clrstr
        for i in self.array:
            print(i)
        return
        # print('\033[m', end='\n')


def print_extra_items(fname, ext):

    mf = mutagen.File(fname)
    if ext.lower() == '.mp3':
        my_keys = ['TALB', 'TIT2', 'TRCK', 'TPE1',
                   'TPE2', 'TPOS', 'TDRC', 'TCON']
        for key in mf:
            if key in my_keys:
                continue
            elif key.startswith('APIC'):
                print('APIC')
                continue
            elif not mf[key][0]:
                continue
            frame_desc = mf[key].__class__.__doc__.partition('\n')[0]
            tab = (16 - len(frame_desc)) * ' '
            print(frame_desc, tab, mf[key][0], end='')
        print
    else:
        my_keys = ['album',
                   'artist',
                   'date',
                   'venue',
                   'genre',
                   'title',
                   'discnumber',
                   'tracknumber',
                   'length']
        for key in mf:
            if key in my_keys:
                continue
            tab = (16 - len(key)) * ' '
            if len(mf[key]) > 1:
                print(key, tab, mf[key])
            elif len(mf[key]) == 1:
                print(key, tab, mf[key][0])


def eachkey(shower, parser, fn, mf, color, opts, files):
    # s = '%s  ' % shower.filename_column(fn, parser.fname_cols())
    pr = shower.pr
    # 
    pr('%s ' % shower.filename_column(fn, parser.fname_cols()), 1)
    for key in parser.colkeywords():
        multival = ''
        if key in mf or True:
            if color:
                # color is a bool 
                pass
            if key == 'tracknumber':
                tn = str(mf.get(key, [0])[0])
                column = tn.rjust(3, ' ')
                
            elif key == 'discnumber':
                dn = str(mf.get(key, [0])[0])
                column = dn.rjust(3, ' ')
            elif key == 'setnumber':
                sn = str(mf.get(key, [0])[0])
                column = sn.rjust(3, ' ')
            else:
                n = 0
                while True:
                    try:
                        val = '%s' % (mf.get(key, [''])[0])
                    except IndexError:
                        break
                    if n > 0:
                        multival += '\n' + val
                    else:
                        multival = val
                    n += 1
                    if 'm' not in opts:
                        break
                column = multival[:24]
            if key in ['title', 'comment']:
                nspaces = 25 - len(column)
            else:
                nspaces = 1 
            pr(column, nspaces)
    return


def _print(msg):
    print(8 * ' ' + msg)
    return


def _help():
    _print('There are several short (one-letter) options for showt.')
    _print('Showt does not take long options')
    _print('')
    _print("'-p' & '-pp' are common options, to colorize the output, which helps readability a lot")
    _print("',' (comma) separates values below into header or row.  '-ali,dnt' shows artist, album, & discnumber")
    _print("    in the header, date, tracknumber & title in the rows.  Tracknumber and title always show in rows")
    _print("'-h' is very common, to print as much of the infomation in common with all tags in a header")
    _print("        instead of in rows.  There are several options for controlling the output, which can be")
    _print("        used with or without the '-h' option.")
    _print('')
    _print("Some options control output:")
    _print("        '-h' show some tag/value pairs in a header")
    _print("with no header keys before comma, print all known tags in the header")
    _print("except tracknumber and title")
    _print("        '-,' show values following the comma in rows and columns")
    _print("        '-G' Group files when a value in the header changes. ie on album title or discnumber change")
    _print("        '-a' show the artist")
    _print("        '-b' show the album title")
    _print("        '-c' composer")
    _print("        '-C' comment")
    _print("        '-d' date (or year)")
    _print("        '-E' shows all items in the tag, but unrecognized items are unformatted")
    _print("        '-f' controls the length in characters to allow the filename, ie -f30. Default is 20.")
    _print("        '-g' genre")
    _print("        '-s' setnumber")
    _print("        '-D' discnumber")
    _print("        '-i' shows some tech info on the tracks at the left column in the rows.")
    _print("        '-j' justify tracknumbers so all are the same width in digits")
    _print("        '-t' tracknumber")
    _print("        '-u' show rows in read sequence (unsorted)")
    _print("        '-v' venue")
    _print("")
    return


def mf_open(fname):
    if os.path.isfile(fname):
        pass
    else:
        return {}
    try:
        return EasyID3(fname)
    except (IOError, OSError, IsADirectoryError):
        return {}
    except ID3NoHeaderError:
        return File(fname)


def main():
    args = sys.argv[1:]
    parser = OParser(args)
    if not parser.files:
        exit()
    '''
    if 's' in parser.optstr:
        while True:
            fname = sys.stdin.readline()
            if fname == '':
                break
            fname = path.realpath(fname.strip('\n'))
            parser.files.append(fname.strip('\n'))
            if not path.isfile(fname.strip('\n')):
                print('non-existent:', fname)
                exit(1)
            if len(parser.files) > 40:
                shower = Shower(parser)
                shower.show()
                parser.files = []
        if len(parser.files):
            shower = Shower(parser)
            shower.show()
        exit(0)
    '''
    s = Shower(parser)
    s.show()
    mp3s = [f for f in parser.files if parser.getext(f) == '.mp3']
    if mp3s:
        s.clean(mp3s, parser.optstr)

if __name__ == '__main__':
    main()
